import path from 'path';
import { filterBySite } from './site-filter';
import { resolveIncludes } from './include';
import { hashContent } from './hash';
import { DepGraph } from './graph';
import { Mapping } from './types';
import { FsOps } from './fs/types';
import { logger } from './logger';

export function compileMapping(
  mapping: Mapping,
  sourcePaths: Record<string, string>,
  site: string,
  graph: DepGraph,
  fs: FsOps
) {
  try {
    const [sourceKey, srcPath] = mapping.from.split(':');
    const sourceBaseDir = sourcePaths[sourceKey];

    if (!sourceBaseDir) {
      throw new Error(`Source '${sourceKey}' not found in sourcePaths`);
    }

    const srcFile = path.join(sourceBaseDir, srcPath);

    logger.info(`Compiling ${mapping.from} â†’ ${mapping.to}`);

    let content = fs.readFileSync(srcFile);
    const deps = new Set<string>([mapping.from]);

    content = resolveIncludes(content, sourcePaths, site, deps, fs);
    content = filterBySite(content, site);

    const hash = hashContent(content);
    logger.debug(`Content hash: ${hash.substring(0, 8)}...`);

    for (const d of deps) {
      graph.addDep(d, mapping.from);
    }

    if (deps.size > 1) {
      logger.debug(`Dependencies: ${Array.from(deps).join(', ')}`);
    }

    const targetDir = path.dirname(mapping.to)
    fs.ensureDir(targetDir)

    fs.writeFileSync(
      mapping.to,
      `<!-- GENERATED BY docs-sync\nhash: ${hash}\n-->\n\n${content}`
    );

    logger.success(`Compiled ${mapping.from}`);
  } catch (error) {
    logger.error(`Failed to compile ${mapping.from}: ${error}`);
    throw new Error(`Failed to compile ${mapping.from}: ${error}`);
  }
}
