import { describe, it, expect, vi, beforeEach } from 'vitest';
import { compileMapping, deleteMapping } from '../compiler';
import { DepGraph } from '../graph';
import type { Mapping } from '../types';
import type { FsOps } from '../fs/types';

// Mock logger to avoid console output during tests
vi.mock('../logger', () => ({
  logger: {
    info: vi.fn(),
    success: vi.fn(),
    warn: vi.fn(),
    error: vi.fn(),
    debug: vi.fn(),
  },
}));

describe('compileMapping', () => {
  let mockFs: FsOps;
  let graph: DepGraph;
  let mapping: Mapping;
  let sourcePaths: Record<string, string>;

  beforeEach(() => {
    graph = new DepGraph();
    mapping = {
      from: 'common:source.md',
      to: 'docs/output.md',
    };

    sourcePaths = {
      common: '/cache/common',
      'other-source': '/cache/other-source',
    };

    mockFs = {
      exists: vi.fn(),
      readFileSync: vi.fn(),
      writeFileSync: vi.fn(),
      ensureDir: vi.fn(),
      stat: vi.fn(),
      unlinkSync: vi.fn(),
    };
  });

  it('should compile simple mapping', () => {
    const sourceContent = '# Hello World';
    vi.mocked(mockFs.readFileSync).mockReturnValue(sourceContent);

    compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);

    expect(mockFs.readFileSync).toHaveBeenCalledWith('/cache/common/source.md');
    expect(mockFs.ensureDir).toHaveBeenCalledWith('docs');
    expect(mockFs.writeFileSync).toHaveBeenCalled();

    const writeCall = vi.mocked(mockFs.writeFileSync).mock.calls[0];
    expect(writeCall[0]).toBe('docs/output.md');
    expect(writeCall[1]).toContain('# Hello World');
    expect(writeCall[1]).toContain('GENERATED BY docs-sync');
  });

  it('should process includes', () => {
    const sourceContent = '<!-- @include common:snippet.md -->';
    const snippetContent = 'Snippet content';

    vi.mocked(mockFs.readFileSync)
      .mockReturnValueOnce(sourceContent)
      .mockReturnValueOnce(snippetContent);
    vi.mocked(mockFs.exists).mockReturnValue(true);

    compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);

    const writeCall = vi.mocked(mockFs.writeFileSync).mock.calls[0];
    expect(writeCall[1]).toContain('Snippet content');
    expect(writeCall[1]).not.toContain('@include');
  });

  it('should filter by site', () => {
    const sourceContent = `
# Header
<!-- @site site-a -->
Content for site-a
<!-- @endsite -->
<!-- @site site-b -->
Content for site-b
<!-- @endsite -->
`;

    vi.mocked(mockFs.readFileSync).mockReturnValue(sourceContent);

    compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);

    const writeCall = vi.mocked(mockFs.writeFileSync).mock.calls[0];
    expect(writeCall[1]).toContain('Content for site-a');
    expect(writeCall[1]).not.toContain('Content for site-b');
  });

  it('should add dependencies to graph', () => {
    const sourceContent = '<!-- @include common:dep1.md -->\n<!-- @include common:dep2.md -->';

    vi.mocked(mockFs.readFileSync).mockReturnValue(sourceContent);
    vi.mocked(mockFs.exists).mockReturnValue(false); // Files don't exist, will use error placeholder

    compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);

    // Should have recorded dependencies even though files don't exist
    const affected = graph.affected('common:dep1.md');
    expect(affected.has('common:source.md')).toBe(false); // deps are recorded but placeholder used
  });

  it('should include content hash in output', () => {
    const sourceContent = '# Test Content';
    vi.mocked(mockFs.readFileSync).mockReturnValue(sourceContent);

    compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);

    const writeCall = vi.mocked(mockFs.writeFileSync).mock.calls[0];
    expect(writeCall[1]).toMatch(/hash: [a-f0-9]+/);
  });

  it('should ensure target directory exists', () => {
    const sourceContent = '# Test';
    vi.mocked(mockFs.readFileSync).mockReturnValue(sourceContent);

    mapping.to = 'docs/nested/path/output.md';
    compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);

    expect(mockFs.ensureDir).toHaveBeenCalledWith('docs/nested/path');
  });

  it('should throw error if source file read fails', () => {
    vi.mocked(mockFs.readFileSync).mockImplementation(() => {
      throw new Error('File not found');
    });

    expect(() => {
      compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);
    }).toThrow();
  });

  it('should handle complex compilation with includes and site filtering', () => {
    const sourceContent = `
# Main Content
<!-- @include common:intro.md -->
<!-- @site site-a -->
Site A specific content
<!-- @endsite -->
<!-- @site site-b -->
Site B specific content
<!-- @endsite -->
`;
    const introContent = 'Introduction text';

    vi.mocked(mockFs.readFileSync)
      .mockReturnValueOnce(sourceContent)
      .mockReturnValueOnce(introContent);
    vi.mocked(mockFs.exists).mockReturnValue(true);

    compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);

    const writeCall = vi.mocked(mockFs.writeFileSync).mock.calls[0];
    const output = writeCall[1] as string;

    expect(output).toContain('Main Content');
    expect(output).toContain('Introduction text');
    expect(output).toContain('Site A specific content');
    expect(output).not.toContain('Site B specific content');
    expect(output).toContain('GENERATED BY docs-sync');
    expect(output).toMatch(/hash:/);
  });

  it('should work with different source keys', () => {
    mapping.from = 'other-source:file.md';
    const sourceContent = '# Other Source';

    vi.mocked(mockFs.readFileSync).mockReturnValue(sourceContent);

    compileMapping(mapping, sourcePaths, 'site-a', graph, mockFs);

    expect(mockFs.readFileSync).toHaveBeenCalledWith('/cache/other-source/file.md');
  });
});

describe('deleteMapping', () => {
  let mockFs: FsOps;
  let graph: DepGraph;
  let mapping: Mapping;

  beforeEach(() => {
    graph = new DepGraph();
    mapping = {
      from: 'common:source.md',
      to: 'docs/output.md',
    };

    mockFs = {
      exists: vi.fn(),
      readFileSync: vi.fn(),
      writeFileSync: vi.fn(),
      ensureDir: vi.fn(),
      stat: vi.fn(),
      unlinkSync: vi.fn(),
    };
  });

  it('should delete output file if it exists', () => {
    vi.mocked(mockFs.exists).mockReturnValue(true);

    deleteMapping(mapping, graph, mockFs);

    expect(mockFs.exists).toHaveBeenCalledWith('docs/output.md');
    expect(mockFs.unlinkSync).toHaveBeenCalledWith('docs/output.md');
  });

  it('should not attempt to delete if output file does not exist', () => {
    vi.mocked(mockFs.exists).mockReturnValue(false);

    deleteMapping(mapping, graph, mockFs);

    expect(mockFs.exists).toHaveBeenCalledWith('docs/output.md');
    expect(mockFs.unlinkSync).not.toHaveBeenCalled();
  });

  it('should remove mapping from dependency graph', () => {
    // Set up graph with dependencies
    graph.addDep('common:source.md', 'target1');
    graph.addDep('common:source.md', 'target2');

    vi.mocked(mockFs.exists).mockReturnValue(true);

    deleteMapping(mapping, graph, mockFs);

    // Verify the dependency was removed
    expect(graph.reverse.has('common:source.md')).toBe(false);
  });

  it('should remove mapping from graph even if file delete fails', () => {
    vi.mocked(mockFs.exists).mockReturnValue(true);
    vi.mocked(mockFs.unlinkSync).mockImplementation(() => {
      throw new Error('Permission denied');
    });

    // Set up graph
    graph.addDep('common:source.md', 'target1');

    expect(() => {
      deleteMapping(mapping, graph, mockFs);
    }).toThrow('Permission denied');

    // Graph should not be modified if operation fails
    expect(graph.reverse.has('common:source.md')).toBe(true);
  });

  it('should handle deletion when mapping has multiple dependencies', () => {
    // Build a graph where source.md is used by multiple targets
    graph.addDep('common:snippet.md', 'common:source.md');
    graph.addDep('common:source.md', 'target1');
    graph.addDep('common:source.md', 'target2');

    console.log('\n=== Before Deleting common:source.md (Multiple Dependencies) ===');
    console.log(graph.visualize());

    vi.mocked(mockFs.exists).mockReturnValue(true);

    deleteMapping(mapping, graph, mockFs);

    console.log('\n=== After Deleting common:source.md ===');
    console.log(graph.visualize());
    console.log('');

    // common:source.md should be removed from graph
    expect(graph.reverse.has('common:source.md')).toBe(false);

    // common:snippet.md should still exist, but common:source.md should be removed from its targets
    const snippetTargets = graph.reverse.get('common:snippet.md');
    expect(snippetTargets?.has('common:source.md')).toBe(false);
  });

  it('should work when mapping has no dependencies in graph', () => {
    vi.mocked(mockFs.exists).mockReturnValue(true);

    // No dependencies added to graph
    deleteMapping(mapping, graph, mockFs);

    expect(mockFs.unlinkSync).toHaveBeenCalledWith('docs/output.md');
    expect(graph.reverse.has('common:source.md')).toBe(false);
  });
});
